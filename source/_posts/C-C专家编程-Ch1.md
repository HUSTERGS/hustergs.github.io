---
title: C-C专家编程 Ch1
tags: C
categories:
  - Programming Language
  - C
abbrlink: 2d475dc9
date: 2020-09-16 15:04:26
---



> 由于参加的实验室主要是以C/C++为主，所以计划把C/C++的一些经典书籍再读一遍，有的是之前就没有读或者读完的。这次就从《C专家编程》开始叭

豆瓣介绍：
> 《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。

1. 对于宏这样的预处理器，只应该适量的使用。最好只用于命名常量，并为一些适当的结构提供简介的记法
2. ISO C
3. 所谓**可移植的代码（portable code）**
   - 只使用已确定的特性
   - 不突破任何由编译器实现的限制
   - 不产生任何由编译器定义的或未确定的或未定义的特性的输出


4. 关于**函数签名**
   函数签名的目的是当我们对函数作前向声明(**forward declaration**)的时候，在形参类型中增加一些信息（而不仅仅是函数名以及返回类型）。这样编译器就可以在变异的时候对函数调用重的实参和函数声明中的形参之间进行一致性检查。
   同时，最好不要省略形参名，由于形参名可以为程序员提供一些信息
<!-- more -->
5. 关于`const`
   ```c
   const int limit = 10; // limit不能被修改
   const int * limitp = &limit; // 不能通过limitp来对其指向的数据进行修改，但limitp本身的值可以被修改
   int i = 27;
   limitp = &i;
   ```
   `const` 最常用的就是用它来限定函数的形参，“我给你一个指向某一个数据的指针，但是你不能通过这个指针来修改这个数据”
   
6. 关于函数传参中的`const`
   首先，根据ANSI标准中的一句话
   > 每个实参都应该具有自己的类型，这样它的值就可以赋值给它对应的形参类型的对象（该对象的类型不能含有限定符）
   也就是说形参传递的过程类似于赋值
   而针对于简单赋值，标准中又有这样一句话
   > 要使赋值操作合法，必须满足下列条件之一
   > 1. 两个操作数都是指向有限定符或者无限定符的相容类型的指针
   > 2. 左边指针所指向的类型必须具有右边指针所指向类型的全部限定符

   考虑以下代码
   ```c
   char *cp;
   const char *ccp;
   ccp = cp; // 合法
   cp = ccp; // 不合法
   ```
   可以理解为**不能通过赋值的方式去除某一个具有限定符的指针的限制**，如果`cp = ccp`是合法的话，那么`cp`与`ccp`此时指向同一个`char`类型数据。但`cp`却没有了`const`限制，也即可以对`ccp`所指向的对象进行修改，这显然是不合法的。所以在标准中要求**左边指针所指向的类型必须具有右边指针所指向类型的全部限定符**

7. 由于隐式类型转换的原因，尤其是有符号到无符号的转换。可能会导致很多条件判断的问题。尤为需要注意的就是`sizeof()`返回的是一个无符号数。
8. 尽量不要在代码中使用无符号类型，以免增加不必要的复杂性。尤其是不要仅仅由于无符号不存在负值就用它表示数量等逻辑上确实不会出现负值的东西。只有在进行位运算相关的计算的时候才使用无符号。